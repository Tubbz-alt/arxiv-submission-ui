"""Private functions to support the :mod:`submit.eventBus` module."""

from itertools import combinations
from collections import defaultdict
from datetime import datetime
from typing import List, Optional, Callable, Tuple, Iterable
from submit.domain.event import Event, CreateSubmissionEvent
from submit.domain.rule import EventRule
from submit.domain.submission import Submission
from submit.services import database, emit


class MultiKeyLookup(object):
    def __init__(self):
        self._callbacks = {}
        self._lookups = defaultdict(set)

    def register(self, callback, **conditions):
        callback_id = id(callback)
        self._callbacks[callback_id] = callback
        self._lookups[tuple(sorted(conditions.keys()))].add(callback_id)

    def lookup(self, **conditions):
        N = len(conditions)
        callback_ids = set()
        for key in [tuple(sorted(i)) for n in range(1, N+1)
                    for i in combinations(conditions.keys(), n)]:
            callback_ids |= self._lookups[key]
        return [self._callbacks[key] for key in callback_ids]


def _apply_rules(submission: Submission, event: Event,
                 rules: List[EventRule]) -> List[Event]:
    """Generate new event(s) by applying rules to a submission event."""
    def _apply(rule: EventRule) -> bool:
        return rule.condition(submission, event)
    return [rule.consequence(submission, event)
            for rule in filter(_apply, rules)]


def _play_events(events: List[Event], rules: List[EventRule],
                 submission: Optional[Submission] = None) \
         -> Tuple[Submission, List[Event]]:
    """Apply a set of events in order."""
    events = sorted(events, key=lambda e: e.created)

    # Need either a creation event or a submission state from which to start.
    if not isinstance(events[0], CreateSubmissionEvent) and submission is None:
        raise RuntimeError('Creation missing and submission not provided')

    extra_events: List[Event] = []    # Generated by applied rules.
    for event in events:
        submission = event.apply(submission)
        emit.emit_event(event, submission)    # Produce a system notification.

        if event.committed:   # Don't create duplicate rule-derived events.
            continue

        # Any rule-derived events should be applied before moving on.
        _extra = _apply_rules(submission, event, rules)
        if len(_extra) > 0:
            submission, _extra = _play_events(_extra, rules, submission)
            extra_events += _extra
    return submission, events + extra_events
