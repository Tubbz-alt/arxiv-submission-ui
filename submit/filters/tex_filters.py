"""Filters for highlighting autotex log files."""

import re


TEX = 'tex'
LATEX = 'latex'
PDFLATEX = 'pdflatex'

ENABLE_TEX = r'(\~+\sRunning tex.*\s\~+)'
ENABLE_LATEX = r'(\~+\sRunning latex.*\s\~+)'
ENABLE_PDFLATEX = r'(\~+\sRunning pdflatex.*\s\~+)'

DISABLE_HTEX = r'(\~+\sRunning htex.*\s\~+)'
DISABLE_HLATEX = r'(\~+\sRunning hlatex.*\s\~+)'
DISABLE_HPDFLATEX = r'(\~+\sRunning hpdflatex.*\s\~+)'

RUN_ORDER = ['last', 'first', 'second', 'third', 'fourth']

def compilation_log_display(autotex_log: str) -> str:
    """
    Highlight interesting features in autotex log.

    Parameters
    ----------
    autotex_log : str
        Complete autotex log containing output from series of TeX runs.

    Returns
    -------
        Returns highlighted autotex log.

    """
    # Create summary information detailing runs and markup key.

    run_summary = ("If you are attempting to compile "
                   "with a specific engine (PDFLaTeX, LaTeX, \nTeX) please "
                   "carefully review the appropriate log below.\n\n"
                   )

    log_summary = (
        "Key: \n"
        "\t<span class=\"tex-fatal\">Severe warnings/errors.</span>'\n"
        "\t<span class=\"tex-danger\">Warnings deemed important</span>'\n"
        "\t<span class=\"tex-warning\">General warnings/errors from packages.</span>'\n"
        
        "\t<span class=\"tex-ignore\">Warnings/Errors deemed unimportant. "
        "Example: undefined references in first TeX run.</span>'\n"
        "\t<span class=\"tex-success\">Indicates positive event, does not guarantee overall success</span>\n"
        "\t<span class=\"tex-info\">Informational markup</span>\n"
        
        "\n"
        "\tNote: Almost all marked up messaged are generated by TeX \n\tengine "
        "or packages. \n\n"
        "\t<span class=\"tex-help\">Links to relevant help pages.</span>\n"
        "\t<span class=\"tex-suggestion\">Suggested solution based on "
        "previous experience.</span>\n"
        "\n\n"
    )

    run_summary = run_summary + (
        "Summary of TeX runs:\n\n"
    )

    new_log = ''

    last_run_for_engine = {}

    # TODO : THIS LIKELY BECOMES ITS OWN ROUTINE

    # Lets figure out what we have in terms of TeX runs
    # ~~~~~~~~~~~ Running hpdflatex for the first time ~~~~~~~~
    # ~~~~~~~~~~~ Running latex for the first time ~~~~~~~~
    run_regex = re.compile(r'\~+\sRunning (.*) for the (.*) time\s\~+',
                           re.IGNORECASE | re.MULTILINE)

    hits = run_regex.findall(autotex_log)

    enable_markup = []
    disable_markup = []

    for run in hits:
        (engine, run) = run

        run_summary = run_summary + f"\tRunning {engine} for {run} time." + '\n'

        last_run_for_engine[engine] = run

        # Now, when we see a normal TeX run, we will eliminate the hypertex run.
        # Since normal run and hypertex run a basically identical this eliminates
        # unnecessary cruft. When hypertex run succeed it will be displayed and
        # marked up appropriately.

        if engine == PDFLATEX:
            disable_markup.append(DISABLE_HPDFLATEX)
            enable_markup.append(ENABLE_PDFLATEX)
        if engine == LATEX:
            disable_markup.append(DISABLE_HLATEX)
            enable_markup.append(ENABLE_LATEX)
        if engine == TEX:
            disable_markup.append(DISABLE_HTEX)
            enable_markup.append(ENABLE_TEX)

    run_summary = run_summary + '\n'


    for e,r in last_run_for_engine.items():
        run_summary = run_summary + f"\tLast run for engine {e} is {r}\n"

    # Ignore lines that we know submitters are not interested in or that
    # contain little useful value

    skip_markup = []

    current_engine = ''
    current_run = ''

    last_run = False

    # Filters  [css class, regex, run spec]
    #
    # Parameters:
    #
    #   css class: class to use for highlighting matching text
    #
    #   regex: regular expression that sucks up everything you want to highlight
    #
    #   run spec: specifies when to start applying filter
    #           OR apply to last run.
    #
    #   Example: run spec of 'second' will apply filter on second, third, ...
    #                run spec of 'last' will run on last run for each engine.
    #
    filters = [

        # Examples
        ['suggestion', r':.*PATH.*', 'second'], # Note ORDER is critical here
        ['help', r':.*PATH.*', 'first'], # otherwise this rule trumps all PATH rules
        ['suggestion', r'Set working directory to.*', ''],
        ['ignore', 'Setting unix time to current time.*', ''],
        ['ignore','Using source archive.*',''],
        ['info', r'Using directory .* for processing.', ''],
        ['warning', r'Copied file .* into working directory.', ''],
        ['danger', 'nostamp: will not stamp PostScript', ''],
        ['danger', r'TeX/AutoTeX.pm', ''],
        ['fatal', r'override', ''],

        # Informational
        ['info', r'\~+\sRunning.*\s\~+', ''],
        ['info', r'(\*\*\* Using TeX Live 2016 \*\*\*)', ''],

        # Success
        ['success', r'(Extracting files from archive:)', ''],

        # Warnings
        ['warning', r'Citation.*undefined', 'first'], # needs to be 'last'
        ['warning', r'Reference.*undefined', 'second'], # needs to be 'last'
        ['warning', r'No .* file', ''],
        ['warning', 'warning', ''],
        ['warning', 'unsupported', ''],
        ['warning', 'unable', ''],
        ['warning', 'ignore', ''],
        ['warning', 'undefined', ''],

        # Danger
        ['danger', r'file (.*) not found', ''],
        ['danger', 'failed', ''],
        ['danger', 'emergency stop', ''],
        ['danger', 'not allowed', ''],
        ['danger', 'does not exist', ''],

        # Fatal
        ['fatal', r'Fatal (.*) error', ''],
        ['fatal', 'fatal', '']
    ]


    line_by_line = autotex_log.splitlines()

    markup_enabled = True

    for line in line_by_line:

        # Disable markup for TeX runs we do not want to markup
        for regex in disable_markup:

            if re.search(regex, line, re.IGNORECASE):
                markup_enabled = False
                #new_log = new_log + f"DISABLE MARKUP:{line}\n"
                break

        # Enable markiup for runs that user is interested in
        for regex in enable_markup:

            if re.search(regex, line, re.IGNORECASE):
                markup_enabled = True
                #new_log = new_log + f"ENABLE MARKUP:{line}\n"
                #log_summary = log_summary + "\tRun: " + re.search(regex, line, re.IGNORECASE).group() + '\n'
                found = run_regex.search(line)
                if found:
                    current_engine = found.group(1)
                    current_run = found.group(2)
                    new_log = new_log + f"Set engine:{current_engine} Run:{current_run}\n"

                if current_engine and current_run:
                    if last_run_for_engine[current_engine] == current_run:
                        new_log = new_log + f"LAST RUN:{current_engine} Run:{current_run}\n"
                        last_run = True
                break


        # Disable markup for TeX runs that we are not interested in.
        if not markup_enabled:
            continue

        # We are not done with this line until there is a match
        done_with_line = False

        for regex in skip_markup:
            if re.search(regex, line, re.IGNORECASE):
                done_with_line = True
                new_log = new_log + f"Skip line {line}\n"
                break

        if done_with_line:
            continue



        # Ignore, Info, Help, Warning, Danger, Fatal
        for level, filter, run in filters:
            regex = r'('+ filter + r')'


            #if run and current_run and re.search('PATH', line):
            #    new_log = new_log + f"RUN:{run}:{RUN_ORDER.index(run)} CURRENT:{current_run}:{RUN_ORDER.index(current_run)}:Last:{last_run_for_engine[current_engine]}" + '\n'

            if not run:
                run = 'first'
            if run and current_run \
                    and ((RUN_ORDER.index(run) > RUN_ORDER.index(current_run)
                          or (run == 'last' and current_run != last_run_for_engine[current_engine]))):
                #new_log = new_log + f"NOT RIGHT RUN LEVEL: SKIP:{filter}" + '\n'
                continue

            #if re.search('PATH', line):
            #    new_log = new_log + f"APPLY FILTER:{filter}" + '\n'

            if re.search(regex, line, re.IGNORECASE):
                line = re.sub(regex, rf'<span class="tex-{level}">\1</span>', line, flags=re.IGNORECASE)
                #if re.search('PATH', line):
                #    rx = rf'<span class="tex-{level}">\1</span>'
                #    new_log = new_log + f"MATCH FILTER:{filter} using level:{level} rx:{rx}" + '\n'
                break

        # Append line to new marked up log
        new_log = new_log + line + '\n'

    # Put together a nice report, list TeX runs, markup info, and marked up log.
    # In future we can add 'Recommendation' section or collect critical errors.
    new_log = run_summary + log_summary + '\n\nMarked Up Log:\n\n' + new_log

    return new_log


